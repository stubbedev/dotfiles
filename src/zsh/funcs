#!/usr/bin/env zsh
# shellcheck disable=SC1091

if is_binary php; then
  function art {
    if is_file "$PWD/artisan"; then
      php artisan "${@:1}"
    elif is_binary artisan; then
      artisan "${@:1}"
    else
      echo "No artisan on current PATH"
    fi
  }
fi

if are_binary git bat fzf awk sed xargs find sort tail head tr grep; then
  function gcm {
    in_git_repo || return 1

    local initial_query="$*"

    local commit_prompt
    local commit_prefix=$(git branch --show-current |
      awk 'match($0, /[A-Z]+-[0-9]+/) { print substr($0, RSTART, RLENGTH) }')
    if [[ -z "$commit_prefix" ]]; then
      commit_prompt="(Enter: commit message)> "
    else
      commit_prompt="(Enter: commit message [$commit_prefix])> "
    fi

    local commit_message=$(fzf --height=1 \
      --query="$initial_query" \
      --reverse \
      --no-info \
      --print-query \
      --prompt="$commit_prompt" </dev/null)

    if [[ -z "$commit_message" ]]; then
      return 0
    fi

    if [[ -z "$commit_prefix" ]]; then
      git commit -m "$commit_message"
    else
      git commit -m "$commit_prefix: $commit_message"
    fi
  }

  function gp {
    in_git_repo || return 1

    local banned_branches=(
      "develop"
      "staging"
      "production"
      "master"
      "main"
    )
    local branch_name=$(git branch --show-current)

    if [[ " ${banned_branches[@]} " =~ " ${branch_name} " ]]; then
      local choice=$(echo -e "No\nYes" |
        fzf \
          --no-input \
          --header="[WARN] Protected Branch: Confirm Push" \
          --reverse \
          --height=3 \
          --no-info \
          --no-multi \
          --exit-0)

      if [[ "$choice" != "Yes" ]]; then
        return 0
      fi
    fi

    git branch --set-upstream-to="origin/$branch_name"
    git push origin "$branch_name"
  }
  function gcr {
    in_git_repo || return 1

    current_tag=$(git tag --sort=version:refname | awk '{print $1}' | tail -n 1)
    local increment_action=$(echo -e "Major\nMinor\nPatch" |
      fzf --prompt="(Enter: select action)> " \
        --height=3 \
        --no-input \
        --no-info)

    local major=$(echo "$current_tag" | grep -oP '^\d+')
    local minor=$(echo "$current_tag" | grep -oP '(?<=\.)\d+(?=\.)')
    local patch=$(echo "$current_tag" | grep -oP '\d+$')

    case $increment_action in
    "Major")
      major=$((major + 1))
      ;;
    "Minor")
      minor=$((minor + 1))
      ;;
    "Patch")
      patch=$((patch + 1))
      ;;
    *)
      return 0
      ;;
    esac
    local release_branch="$major.$minor.$patch"
    git checkout -b "release/$release_branch"
  }
  function gcb {
    in_git_repo || return 1

    local initial_query=""
    if [[ -n "$1" ]]; then
      initial_query="$1"
    fi

    local git_branches=$(git branch --all | awk '{sub(/^remotes\/origin\//, "", $1); print $1}' | sort -u)

    local branch_name=$(echo -e $git_branches |
      fzf --prompt="(Enter: checkout branch, Ctrl+C: create new branch)> " \
        --query="$initial_query" \
        --bind 'enter:accept' \
        --exact \
        --select-1 \
        --exit-0 \
        --print-query \
        --no-info \
        --height=5 |
      tail -n1)

    if [[ -n "$branch_name" && $(echo -e $git_branches | grep -Fx "$branch_name") ]]; then
      git checkout "$branch_name"
      return 0
    fi

    if [[ -z "$branch_name" ]]; then
      branch_name=$(fzf \
        --prompt="(Enter: create branch [Ticket: ABC-1234 || Tag: 4.3.21], Ctrl+C: cancel command)> " \
        --height=1 \
        --reverse \
        --no-info \
        --print-query </dev/null)
    fi

    if [[ -z "$branch_name" ]]; then
      return 0
    fi

    local tag_mask="^[0-9]+\.[0-9]+\.[0-9]+$"
    if [[ $branch_name =~ $tag_mask ]]; then
      git checkout -b "release/$branch_name" || git checkout "release/$branch_name"
      return 0
    fi

    local branch_prefix=$(echo -e "feature\nbugfix\nhotfix" |
      fzf --prompt="(Enter: select prefix)> " \
        --height=3 \
        --no-input \
        --no-info)

    if [[ -z "$branch_prefix" ]]; then
      return 0
    fi

    local new_branch_name
    local branch_suffix=$(fzf \
      --height=1 \
      --reverse \
      --no-info \
      --print-query \
      --prompt="(Enter: select suffix)> " </dev/null |
      head -1)

    if [[ -n "$branch_suffix" ]]; then
      branch_suffix=$(echo "$branch_suffix" | tr '[:upper:]' '[:lower:]' | sed 's/ /-/g')
      new_branch_name="$branch_prefix/$branch_name-$branch_suffix"
    else
      new_branch_name="$branch_prefix/$branch_name"
    fi

    if [[ "$new_branch_name" != "/" ]]; then
      git checkout -b "$new_branch_name" || git checkout "$new_branch_name"
    fi
  }

  function ga {
    in_git_repo || return 1

    local direct_add="$@"
    if [[ -n "$@" ]]; then
      git add "$@"
    fi
    local temp_pwd="$PWD"
    cd $(git rev-parse --show-toplevel)

    local git_status=$(git status --porcelain)
    local tracked_files=$(echo -e "$git_status" | awk '/^.M|^MM|^R.M/ {if ($4 != "") print $4; else print $2}' | sort -u)
    local deleted_files=$(echo -e "$git_status" | awk '/^.D/ {print $2}')
    local untracked_files=$(echo -e "$git_status" | awk '/^\?\?/ {print $2}' | xargs -I {} find "{}" -type f -print)

    if [[ -n "$tracked_files" ]]; then
      local tracked_selected=$(printf "%s\n" $tracked_files | fzf --multi \
        --preview='git diff --diff-filter=M -- {} | bat --style=numbers --color=always' \
        --preview-window='up:90%:wrap:nohidden' \
        --prompt="(Tab: toggle file, Shift+Tab: toggle all files, Enter: submit selection, Ctrl+C: cancel selection)> " \
        --header="Add tracked files" \
        --bind 'shift-tab:toggle-all' \
        --bind "tab:toggle" \
        --bind 'enter:transform:[[ $FZF_SELECT_COUNT -gt 0 ]] && echo accept || echo abort' \
        --no-info \
        --exit-0)

      if [[ -n "$tracked_selected" ]]; then
        local tracked_selection=($(echo "$tracked_selected" | awk '{for(i=1; i<=NF; i++) print $i}'))
        for file in "${tracked_selection[@]}"; do
          git add "$file" -p
        done
      fi
    fi

    if [[ -n "$deleted_files" ]]; then
      local deleted_selected=$(printf "%s\n" $deleted_files |
        fzf --multi \
          --preview='git diff --diff-filter=D -- {} | bat --style=numbers --color=always' \
          --preview-window='up:90%:wrap:nohidden' \
          --prompt="(Tab: toggle file, Shift+Tab: toggle all files, Enter: submit selection, Ctrl+C: cancel selection)> " \
          --header="Add deleted files" \
          --bind 'shift-tab:toggle-all' \
          --bind "tab:toggle" \
          --bind 'enter:transform:[[ $FZF_SELECT_COUNT -gt 0 ]] && echo accept || echo abort' \
          --no-info \
          --exit-0)

      if [[ -n "$deleted_selected" ]]; then
        local deleted_selection=($(echo "$deleted_selected" | awk '{for(i=1; i<=NF; i++) print $i}'))
        for file in "${deleted_selection[@]}"; do
          git add "$file"
        done
      fi
    fi

    if [[ -n "$untracked_files" ]]; then
      local untracked_selected=$(printf "%s\n" $untracked_files |
        fzf --multi \
          --preview='bat --style=numbers --color=always {}' \
          --preview-window='up:90%:wrap:nohidden' \
          --prompt="(Tab: toggle file, Shift+Tab: toggle all files, Enter: submit selection, Ctrl+C: cancel selection)> " \
          --header="Add untracked files" \
          --bind 'shift-tab:toggle-all' \
          --bind "tab:toggle" \
          --bind 'enter:transform:[[ $FZF_SELECT_COUNT -gt 0 ]] && echo accept || echo abort' \
          --no-info \
          --exit-0)

      if [[ -n "$untracked_selected" ]]; then
        local untracked_selection=($(echo "$untracked_selected" | awk '{for(i=1; i<=NF; i++) print $i}'))
        for file in "${untracked_selection[@]}"; do
          git add "$file"
        done
      fi
    fi
    cd "$temp_pwd"
    clear
    echo -e ""
    git status --short
  }

  function gsd {
    in_git_repo || return 1

    git diff
  }

  function gd {
    in_git_repo || return 1

    local initial_query=""
    if [[ -n "$1" ]]; then
      initial_query="$1"
    fi

    local current_branch=$(git branch --show-current)
    local git_branches=$(git branch --all | awk '{print $1}')
    local remote_branch=$(echo -e $git_branches |
      fzf --prompt="(Enter: select comparison branch)> " \
        --query="$initial_query" \
        --select-1 \
        --exit-0 \
        --print-query \
        --no-info \
        --height=5 |
      tail -n1)

    git diff $current_branch..$remote_branch --color
  }

  function gcd {
    in_git_repo || return 1

    local initial_query=""
    if [[ -n "$1" ]]; then
      initial_query="$1"
    fi

    local current_branch=$(git branch --show-current)
    local git_branches=$(git branch --all | awk '{print $1}')
    local target_branch=$(echo -e $git_branches |
      fzf --prompt="(Enter: select target branch for diff)> " \
        --query="$initial_query" \
        --select-1 \
        --exit-0 \
        --print-query \
        --no-info \
        --height=5 |
      tail -n1)

    if [[ -z "$target_branch" ]]; then
      return 0
    fi

    # Clean branch names for filename (remove remotes/origin/ prefix and special chars)
    local clean_current=$(echo "$current_branch" | sed 's/remotes\/origin\///' | sed 's/\//-/g')
    local clean_target=$(echo "$target_branch" | sed 's/remotes\/origin\///' | sed 's/\//-/g')
    local patch_file="${clean_current}--${clean_target}.diff"

    git diff $current_branch..$target_branch >"$patch_file"

    if [[ -f "$patch_file" ]]; then
      echo "âœ… Patch file created: $patch_file"
    else
      echo "âŒ Failed to create patch file"
      return 1
    fi
  }

  function gst {
    in_git_repo || return 1

    echo ""
    git status --short
  }
  function gg {
    in_git_repo || return 1

    local current_branch=$(git branch --show-current)
    git branch --set-upstream-to="origin/$current_branch"
    git pull
  }
  function gga {
    in_git_repo || return 1

    local current_branch=$(git branch --show-current)
    git branch --set-upstream-to="origin/$current_branch"
    git pull --all
  }
  function gf {
    in_git_repo || return 1

    git fetch
  }
  function gfa {
    in_git_repo || return 1

    git fetch --all
  }
  function ghr {
    in_git_repo || return 1

    git reset --hard HEAD~
  }
  function ghrn {
    in_git_repo || return 1

    git reset --hard HEAD~"$1"
  }
  function gr {
    in_git_repo || return 1

    git reset --soft HEAD~
  }
  function grn {
    in_git_repo || return 1

    git reset --soft HEAD~"$1"
  }
  function gsa {
    in_git_repo || return 1

    git stash
  }
  function gw {
    in_git_repo || return 1

    if [[ -z "$(git status --porcelain)" ]]; then
      return 0
    fi

    local choice=$(echo -e "No\nYes" |
      fzf \
        --no-input \
        --header="[WARN] Local Branch: Wipe Non-Pushed Changes" \
        --reverse \
        --height=3 \
        --no-info \
        --no-multi \
        --exit-0)

    if [[ "$choice" != "Yes" ]]; then
      return 0
    fi

    git add .
    git stash
    git stash drop
  }
  function ggo {
    in_git_repo || return 1

    local initial_query=""
    if [[ -n "$1" ]]; then
      initial_query="$1"
    fi

    local git_branches=$(git branch --all | awk '{sub(/^[* ] */, ""); sub(/^remotes\/origin\//, ""); print $1}' | grep -v '^HEAD' | sort -u)

    local selected_branch=$(echo -e "$git_branches" |
      fzf --prompt="(Enter: select branch to pull from origin)> " \
        --query="$initial_query" \
        --select-1 \
        --exit-0 \
        --no-info \
        --height=10)

    if [[ -n "$selected_branch" && $(echo -e "$git_branches" | grep -Fx "$selected_branch") ]]; then
      git pull origin "$selected_branch"
    fi
  }
  function in_git_repo {
    if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
      return 1
    fi
  }

fi

if is_binary bat; then
  function view_git_file {
    curl "$(echo "$1" | sed "s/github.com/raw.githubusercontent.com/g" | sed "s/\/blob\//\/refs\/heads\//g")" | bat -f -l "${1##*\.}"
  }
else
  function view_git_file {
    curl "$(echo "$1" | sed "s/github.com/raw.githubusercontent.com/g" | sed "s/\/blob\//\/refs\/heads\//g")" | cat
  }
fi

if is_binary ss; then
  function pop {
    ss -lptn " sport = :$1"
  }
fi

if is_binary uv; then
  function pysrc {
    if ! is_file "$PWD/venv/bin/activate"; then
      uv venv ./venv
    fi
    is_file "$PWD/venv/bin/activate" && source "$PWD/venv/bin/activate"
  }
fi

if is_binary fzf; then
  function fzf-project-picker {
    SELECTED_DIR="$(fzf-project-picker-util "$@")"
    if [[ -n "$SELECTED_DIR" ]]; then
      cd "$SELECTED_DIR"
    fi
    clear
  }
  function fzf-directory-picker {
    SELECTED_DIR="$(fzf-directory-picker-util "$@")"
    if [[ -n "SELECTED_DIR" ]]; then
      cd "$SELECTED_DIR"
    fi
    clear
  }
fi

if is_binary home-manager; then
  function hm {
    # Check for --debug flag in arguments
    local debug_mode=false
    local filtered_args=()
    for arg in "$@"; do
      if [[ "$arg" == "--debug" ]]; then
        debug_mode=true
        export BIN_INSTALL_DEBUG=1
      else
        filtered_args+=("$arg")
      fi
    done

    if is_binary hyprctl; then
      export USE_HYPRLAND=true
    else
      export USE_HYPRLAND=false
    fi

    case "${filtered_args[1]:-}" in
    "update" | "upgrade")
      echo "ğŸ”„ Starting system update process..."

      # Request sudo access upfront
      echo "ğŸ” Requesting elevated privileges..."
      sudo -v

      # Disable job control messages
      setopt local_options no_notify no_monitor

      # Keep sudo alive in background
      (while true; do
        sudo -n true
        sleep 60
      done) 2>/dev/null &
      local sudo_keepalive_pid=$!

      # Run parallel updates for different package managers
      local pids=()
      local temp_dir=$(mktemp -d)
      local update_jobs=()

      # Update system packages in background
      if is_binary pacman; then
        (
          sudo pacman -Syu --noconfirm >"$temp_dir/pacman.log" 2>&1
          echo $? >"$temp_dir/pacman.status"
        ) &
        pids+=($!)
        update_jobs+=("pacman")
      elif is_binary apt; then
        (
          sudo apt update >"$temp_dir/apt.log" 2>&1 && sudo apt upgrade -y >>"$temp_dir/apt.log" 2>&1
          echo $? >"$temp_dir/apt.status"
        ) &
        pids+=($!)
        update_jobs+=("apt")
      elif is_binary dnf; then
        (
          sudo dnf update -y >"$temp_dir/dnf.log" 2>&1 && sudo dnf upgrade -y >>"$temp_dir/dnf.log" 2>&1
          echo $? >"$temp_dir/dnf.status"
        ) &
        pids+=($!)
        update_jobs+=("dnf")
      fi

      # Update snaps if installed in background
      if is_binary snap; then
        (
          sudo snap refresh >"$temp_dir/snap.log" 2>&1
          echo $? >"$temp_dir/snap.status"
        ) &
        pids+=($!)
        update_jobs+=("snap")
      fi

      # Update flatpaks if installed in background
      if is_binary flatpak; then
        (
          flatpak update -y >"$temp_dir/flatpak.log" 2>&1
          echo $? >"$temp_dir/flatpak.status"
        ) &
        pids+=($!)
        update_jobs+=("flatpak")
      fi

      # Update nix flake and channels in background
      (
        nix flake update --flake "$HOME/.stubbe/src/nix/home-manager" >"$temp_dir/nix.log" 2>&1
        nix-channel --update >>"$temp_dir/nix.log" 2>&1
        echo $? >"$temp_dir/nix.status"
      ) &
      pids+=($!)
      update_jobs+=("nix")

      # Wait for all background updates to complete
      echo "â³ Waiting for all updates to complete..."
      echo ""
      for pid in "${pids[@]}"; do
        wait "$pid" 2>/dev/null
      done

      # Kill the sudo keep-alive process and wait for it
      if [[ -n "$sudo_keepalive_pid" ]]; then
        kill -9 "$sudo_keepalive_pid" 2>/dev/null
        wait "$sudo_keepalive_pid" 2>/dev/null
      fi

      # Disown any remaining jobs from this function
      disown 2>/dev/null

      # Display results in unified format
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo -e "\033[1;36mğŸ“Š Update Summary\033[0m"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo ""

      for job in "${update_jobs[@]}"; do
        local status_file="$temp_dir/$job.status"
        local log_file="$temp_dir/$job.log"
        local status_code=0

        if [[ -f "$status_file" ]]; then
          status_code=$(cat "$status_file")
        fi

        # Format job name with emoji
        local job_display=""
        case "$job" in
        "pacman") job_display="ğŸ“¦ Pacman" ;;
        "apt") job_display="ğŸ“¦ APT" ;;
        "dnf") job_display="ğŸ“¦ DNF" ;;
        "snap") job_display="ğŸ“± Snap" ;;
        "flatpak") job_display="ğŸ“¦ Flatpak" ;;
        "nix") job_display="â„ï¸  Nix" ;;
        esac

        # Display status with color
        if [[ "$status_code" -eq 0 ]]; then
          echo -e "\033[1;32mâœ“\033[0m $job_display"
        else
          echo -e "\033[1;31mâœ—\033[0m $job_display \033[31m(exit code: $status_code)\033[0m"
        fi

        # Display relevant log output (last few lines or errors)
        if [[ -f "$log_file" ]]; then
          local log_content=$(cat "$log_file")

          # Show summary based on package manager
          case "$job" in
          "apt")
            local upgraded=$(echo "$log_content" | grep -oP '\d+(?= upgraded)' | head -1)
            local installed=$(echo "$log_content" | grep -oP '\d+(?= newly installed)' | head -1)
            upgraded=${upgraded:-0}
            installed=${installed:-0}
            if [[ "$upgraded" != "0" || "$installed" != "0" ]]; then
              echo -e "  \033[90mâ””â”€\033[0m Upgraded: $upgraded, Installed: $installed"
            else
              echo -e "  \033[90mâ””â”€\033[0m All packages up to date"
            fi
            ;;
          "pacman")
            local packages=$(echo "$log_content" | grep "^upgrading\|^installing" | wc -l)
            packages=${packages:-0}
            if [[ "$packages" != "0" ]]; then
              echo -e "  \033[90mâ””â”€\033[0m Updated $packages package(s)"
            fi
            ;;
          "snap")
            local refreshed=$(echo "$log_content" | grep -v "^All snaps up to date" | grep -c "refreshed")
            refreshed=${refreshed:-0}
            if [[ "$refreshed" != "0" ]]; then
              echo -e "  \033[90mâ””â”€\033[0m Refreshed $refreshed snap(s)"
            else
              echo -e "  \033[90mâ””â”€\033[0m All snaps up to date"
            fi
            ;;
          "flatpak")
            local updates=$(echo "$log_content" | grep -oP '(?<=Updating: )\d+' | head -1)
            updates=${updates:-0}
            if [[ "$updates" != "0" ]]; then
              echo -e "  \033[90mâ””â”€\033[0m Updated $updates package(s)"
            else
              echo -e "  \033[90mâ””â”€\033[0m No updates available"
            fi
            ;;
          "nix")
            local updated=$(echo "$log_content" | grep "Updated input" | wc -l)
            updated=${updated:-0}
            if [[ "$updated" != "0" ]]; then
              echo -e "  \033[90mâ””â”€\033[0m Updated $updated input(s)"
            fi
            ;;
          esac

          # Show errors if status was non-zero
          if [[ "$status_code" -ne 0 ]]; then
            echo -e "  \033[90mâ””â”€\033[0m \033[31mError details:\033[0m"
            echo "$log_content" | tail -5 | sed 's/^/     /'
          fi
        fi
        echo ""
      done

      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo -e "\033[90mFull logs available at: $temp_dir\033[0m"
      echo ""

      # Run home-manager switch for upgrade
      if [[ "${filtered_args[1]}" == "upgrade" ]]; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo -e "\033[1;34mğŸ  Home Manager\033[0m"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""

        # Stream and format home-manager output in real-time
        home-manager switch --impure "${filtered_args[@]:1}" 2>&1 | while IFS= read -r line; do
          if [[ "$line" =~ "building" ]]; then
            echo -e "\033[1;36mğŸ”¨ Building:\033[0m ${line#*building}"
          elif [[ "$line" =~ "Activating" ]]; then
            echo -e "\033[1;32mâœ“ Activating:\033[0m ${line#*Activating}"
          elif [[ "$line" =~ "Starting Home Manager activation" ]]; then
            echo -e "\033[1;34mğŸ  Starting Home Manager activation\033[0m"
          elif [[ "$line" =~ "creating" ]]; then
            echo -e "\033[90m  â””â”€\033[0m Creating: ${line#*creating}"
          elif [[ "$line" =~ "reloading" ]]; then
            echo -e "\033[90m  â””â”€\033[0m Reloading: ${line#*reloading}"
          elif [[ "$line" =~ "error:" ]] || [[ "$line" =~ "warning:" ]]; then
            echo -e "\033[31mâš ï¸  $line\033[0m"
          elif [[ -n "$line" ]]; then
            # Print other non-empty lines with subtle formatting
            echo -e "\033[90m  $line\033[0m"
          fi
        done

        local hm_exit_code=${pipestatus[1]}

        echo ""
        if [[ $hm_exit_code -eq 0 ]]; then
          echo -e "\033[1;32mâœ… Home Manager configuration applied successfully!\033[0m"
          src_zsh
        else
          echo -e "\033[1;31mâŒ Home Manager failed with exit code: $hm_exit_code\033[0m"
        fi
        echo ""

        return $hm_exit_code
      fi

      echo "âœ… Update process completed!"
      ;;
    "search")
      local search_term="${filtered_args[2]:-}"

      if [[ -z "$search_term" ]]; then
        if is_binary fzf; then
          search_term=$(fzf --height=1 \
            --reverse \
            --no-info \
            --print-query \
            --prompt="ğŸ” Enter package name to search> " </dev/null)

          if [[ -z "$search_term" ]]; then
            return 0
          fi
        else
          echo -e "\033[33mUsage:\033[0m hm search \033[36m<package_name>\033[0m"
          return 1
        fi
      fi

      echo -e "ğŸ” \033[1;34mSearching nix packages for:\033[0m \033[1;36m$search_term\033[0m" >&2
      if is_binary fzf; then
        local formatted_output
        formatted_output=$(nix search nixpkgs "^$search_term" --json 2>/dev/null |
          jq -r 'to_entries[] | "\(.key)|\(.value.pname // "unknown")|\(.value.description // "no description")|\(.value.version // "unknown")"')

        local selected
        selected=$(echo "$formatted_output" |
          while IFS='|' read -r package pname description version; do
            clean_package=$(echo "$package" | sed 's/^legacyPackages\.[^.]*\.//')
            printf "\033[1;36m%-30s\033[0m \033[32m%-15s\033[0m \033[33m%-10s\033[0m \033[37m%s\033[0m\n" \
              "$clean_package" "$pname" "$version" "$description"
          done |
          fzf --ansi \
            --exact \
            --multi \
            --preview 'echo -e "\033[1;34mPackage:\033[0m \033[1;36m{1}\033[0m\n\033[1;34mProgram:\033[0m \033[32m{2}\033[0m\n\033[1;34mVersion:\033[0m \033[33m{3}\033[0m\n\033[1;34mDescription:\033[0m \033[37m{4}\033[0m"' \
            --preview-window=up:6:wrap \
            --header="ğŸ” Select package(s) (Tab: multi-select, Enter: print names, Esc: exit)" \
            --bind='ctrl-a:select-all,ctrl-d:deselect-all' \
            --color='fg:white,hl:yellow,fg+:bright-cyan,hl+:bright-yellow,info:green,prompt:cyan,pointer:bright-magenta,marker:bright-red,spinner:yellow,header:blue')

        if [[ -n "$selected" ]]; then
          echo "$selected" | while read -r line; do
            echo "$line" | awk '{print $1}'
          done
        fi
      else
        if is_binary jq; then
          echo -e "ğŸ“¦ \033[1;34mAvailable packages matching '\033[1;36m$search_term\033[1;34m':\033[0m" >&2
          echo "" >&2
          nix search nixpkgs "^$search_term" --json 2>/dev/null |
            jq -r 'to_entries[] | "\(.key)|\(.value.pname // "unknown")|\(.value.description // "no description")|\(.value.version // "unknown")"' |
            while IFS='|' read -r package pname description version; do
              clean_package=$(echo "$package" | sed 's/^legacyPackages\.[^.]*\.//')
              printf "  \033[1;36m%-30s\033[0m \033[32m%-15s\033[0m \033[33m%-10s\033[0m \033[37m%s\033[0m\n" \
                "$clean_package" "$pname" "$version" "$description"
            done >&2
        else
          echo -e "ğŸ“¦ \033[1;34mSearching packages...\033[0m" >&2
          nix search nixpkgs "^$search_term" 2>/dev/null >&2 || nix-env -qaP | grep -i "^$search_term" >&2
        fi
      fi
      ;;
    *)
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo -e "\033[1;34mğŸ  Home Manager\033[0m"
      echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
      echo ""

      # Stream and format home-manager output in real-time
      home-manager "${filtered_args[@]}" --impure 2>&1 | while IFS= read -r line; do
        if [[ "$line" =~ "building" ]]; then
          echo -e "\033[1;36mğŸ”¨ Building:\033[0m ${line#*building}"
        elif [[ "$line" =~ "Activating" ]]; then
          echo -e "\033[1;32mâœ“ Activating:\033[0m ${line#*Activating}"
        elif [[ "$line" =~ "Starting Home Manager activation" ]]; then
          echo -e "\033[1;34mğŸ  Starting Home Manager activation\033[0m"
        elif [[ "$line" =~ "creating" ]]; then
          echo -e "\033[90m  â””â”€\033[0m Creating: ${line#*creating}"
        elif [[ "$line" =~ "reloading" ]]; then
          echo -e "\033[90m  â””â”€\033[0m Reloading: ${line#*reloading}"
        elif [[ "$line" =~ "error:" ]] || [[ "$line" =~ "warning:" ]]; then
          echo -e "\033[31mâš ï¸  $line\033[0m"
        elif [[ -n "$line" ]]; then
          # Print other non-empty lines with subtle formatting
          echo -e "\033[90m  $line\033[0m"
        fi
      done

      local hm_exit_code=${pipestatus[1]}

      echo ""
      if [[ $hm_exit_code -eq 0 ]]; then
        echo -e "\033[1;32mâœ… Home Manager configuration applied successfully!\033[0m"
      else
        echo -e "\033[1;31mâŒ Home Manager failed with exit code: $hm_exit_code\033[0m"
      fi
      echo ""

      return $hm_exit_code
      ;;
    esac

    # Unset debug flag after execution
    if [[ "$debug_mode" == "true" ]]; then
      unset BIN_INSTALL_DEBUG
    fi
  }
fi
